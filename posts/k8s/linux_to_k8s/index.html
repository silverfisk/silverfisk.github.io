<!doctype html><html lang=en><head><title>Kubernetes: The API-Driven Platform for Linux Engineers · linux-konsult.com
</title><meta charset=utf-8><meta name=viewport content="width=device-width,initial-scale=1"><meta name=color-scheme content="light dark"><meta name=author content="Tom"><meta name=description content="
  From Linux to Kubernetes: From Files to APIs
  
    
    Link to heading
  


  1. Introduction: Bridging the Gap
  
    
    Link to heading
  

For veteran Linux engineers, a core principle that drives much of Linux’s simplicity is “everything is a file.” Devices, processes, network interfaces, and more all appear as files or directories, making them easy to inspect and manipulate. In contrast, Kubernetes takes a similarly unifying approach but with an API-driven model, enabling declarative management of infrastructure at scale."><meta name=keywords content="blog,devops,sustainability,esp8266,prometheus,grafana"><meta name=twitter:card content="summary"><meta name=twitter:title content="Kubernetes: The API-Driven Platform for Linux Engineers"><meta name=twitter:description content="From Linux to Kubernetes: From Files to APIs Link to heading 1. Introduction: Bridging the Gap Link to heading For veteran Linux engineers, a core principle that drives much of Linux’s simplicity is “everything is a file.” Devices, processes, network interfaces, and more all appear as files or directories, making them easy to inspect and manipulate. In contrast, Kubernetes takes a similarly unifying approach but with an API-driven model, enabling declarative management of infrastructure at scale."><meta property="og:url" content="https://linux-konsult.com/posts/k8s/linux_to_k8s/"><meta property="og:site_name" content="linux-konsult.com"><meta property="og:title" content="Kubernetes: The API-Driven Platform for Linux Engineers"><meta property="og:description" content="From Linux to Kubernetes: From Files to APIs Link to heading 1. Introduction: Bridging the Gap Link to heading For veteran Linux engineers, a core principle that drives much of Linux’s simplicity is “everything is a file.” Devices, processes, network interfaces, and more all appear as files or directories, making them easy to inspect and manipulate. In contrast, Kubernetes takes a similarly unifying approach but with an API-driven model, enabling declarative management of infrastructure at scale."><meta property="og:locale" content="en"><meta property="og:type" content="article"><meta property="article:section" content="posts"><meta property="article:published_time" content="2025-01-25T00:00:00+00:00"><meta property="article:modified_time" content="2025-01-25T00:00:00+00:00"><meta property="article:tag" content="Linux"><meta property="article:tag" content="K8s"><meta property="article:tag" content="API"><meta property="article:tag" content="GPU"><link rel=canonical href=https://linux-konsult.com/posts/k8s/linux_to_k8s/><link rel=preload href=/fonts/fa-brands-400.woff2 as=font type=font/woff2 crossorigin><link rel=preload href=/fonts/fa-regular-400.woff2 as=font type=font/woff2 crossorigin><link rel=preload href=/fonts/fa-solid-900.woff2 as=font type=font/woff2 crossorigin><link rel=stylesheet href=/css/coder.min.bb7a78bfb4e57aba6e78691ce9ad3fef35238fff2f55149e48bb3c43becd260c.css integrity="sha256-u3p4v7TlerpueGkc6a0/7zUjj/8vVRSeSLs8Q77NJgw=" crossorigin=anonymous media=screen><link rel=icon type=image/svg+xml href=/images/favicon.svg sizes=any><link rel=icon type=image/png href=/images/favicon-32x32.png sizes=32x32><link rel=icon type=image/png href=/images/favicon-16x16.png sizes=16x16><link rel=apple-touch-icon href=/images/apple-touch-icon.png><link rel=apple-touch-icon sizes=180x180 href=/images/apple-touch-icon.png><link rel=manifest href=/site.webmanifest><link rel=mask-icon href=/images/safari-pinned-tab.svg color=#5bbad5></head><body class="preload-transitions colorscheme-light"><div class=float-container><a id=dark-mode-toggle class=colorscheme-toggle><i class="fa-solid fa-adjust fa-fw" aria-hidden=true></i></a></div><main class=wrapper><nav class=navigation><section class=container><a class=navigation-title href=https://linux-konsult.com/>linux-konsult.com
</a><input type=checkbox id=menu-toggle>
<label class="menu-button float-right" for=menu-toggle><i class="fa-solid fa-bars fa-fw" aria-hidden=true></i></label><ul class=navigation-list><li class=navigation-item><a class=navigation-link href=/posts>Blog</a></li><li class=navigation-item><a class=navigation-link href=/categories>Topics</a></li><li class=navigation-item><a class=navigation-link href=/links>Links</a></li><li class=navigation-item><a class=navigation-link href=http://whoami.linux-konsult.com>Resume</a></li></ul></section></nav><div class=content><section class="container post"><article><header><div class=post-title><h1 class=title><a class=title-link href=https://linux-konsult.com/posts/k8s/linux_to_k8s/>Kubernetes: The API-Driven Platform for Linux Engineers</a></h1></div><div class=post-meta><div class=date><span class=posted-on><i class="fa-solid fa-calendar" aria-hidden=true></i>
<time datetime=2025-01-25T00:00:00Z>January 25, 2025
</time></span><span class=reading-time><i class="fa-solid fa-clock" aria-hidden=true></i>
8-minute read</span></div><div class=categories><i class="fa-solid fa-folder" aria-hidden=true></i>
<a href=/categories/kubernetes/>Kubernetes</a></div><div class=tags><i class="fa-solid fa-tag" aria-hidden=true></i>
<span class=tag><a href=/tags/linux/>Linux</a>
</span><span class=separator>•</span>
<span class=tag><a href=/tags/k8s/>K8s</a>
</span><span class=separator>•</span>
<span class=tag><a href=/tags/api/>API</a>
</span><span class=separator>•</span>
<span class=tag><a href=/tags/gpu/>GPU</a></span></div></div></header><div class=post-content><h1 id=from-linux-to-kubernetes-from-files-to-apis>From Linux to Kubernetes: From Files to APIs
<a class=heading-link href=#from-linux-to-kubernetes-from-files-to-apis><i class="fa-solid fa-link" aria-hidden=true title="Link to heading"></i>
<span class=sr-only>Link to heading</span></a></h1><h2 id=1-introduction-bridging-the-gap>1. Introduction: Bridging the Gap
<a class=heading-link href=#1-introduction-bridging-the-gap><i class="fa-solid fa-link" aria-hidden=true title="Link to heading"></i>
<span class=sr-only>Link to heading</span></a></h2><p>For veteran Linux engineers, a core principle that drives much of Linux’s simplicity is <a href=https://en.wikipedia.org/wiki/Everything_is_a_file class=external-link target=_blank rel=noopener><strong>“everything is a file.”</strong></a> Devices, processes, network interfaces, and more all appear as files or directories, making them easy to inspect and manipulate. In contrast, Kubernetes takes a similarly unifying approach but with an <strong>API-driven</strong> model, enabling declarative management of infrastructure at scale.</p><p>This article is for you — <strong>a senior Linux/DevOps engineer</strong> — to show how your Linux expertise can translate to Kubernetes, and understand where Kubernetes still depends on Linux foundations.</p><hr><h2 id=2-linuxs-bedrock-everything-is-a-file>2. Linux’s Bedrock: “Everything is a File”
<a class=heading-link href=#2-linuxs-bedrock-everything-is-a-file><i class="fa-solid fa-link" aria-hidden=true title="Link to heading"></i>
<span class=sr-only>Link to heading</span></a></h2><p>Linux typically handle resources through standard file operations such as:</p><ul><li><a href=https://www.kernel.org/doc/html/latest/filesystems/proc.html class=external-link target=_blank rel=noopener><strong><code>/proc</code></strong></a>: Exposes process and kernel information (e.g., <code>/proc/cpuinfo</code>, <code>/proc/&lt;PID></code>).</li><li><a href=https://www.kernel.org/doc/html/latest/admin-guide/sysctl/ class=external-link target=_blank rel=noopener><strong><code>/sys</code></strong></a>: Provides a window into kernel subsystems (devices, power states, networking at <a href=https://www.kernel.org/doc/html/latest/admin-guide/sysctl/net.html class=external-link target=_blank rel=noopener><code>/sys/class/net</code></a>, etc.).</li><li><strong><code>/dev</code></strong>: Houses device nodes for block and character devices (e.g., <code>/dev/sda</code>, <code>/dev/null</code>).</li><li><strong><code>Sockets/Pipes</code></strong>: Used for IPC and network communication; they appear as special files (e.g., <code>/tmp/mysocket</code>).</li></ul><p>This unifying file concept ensures that standard utilities like <code>cat</code>, <code>echo</code>, and <code>ls</code> can read or modify system state without specialized tooling.</p><hr><h2 id=3-kubernetes-everything-is-an-api>3. Kubernetes: “Everything is an API”
<a class=heading-link href=#3-kubernetes-everything-is-an-api><i class="fa-solid fa-link" aria-hidden=true title="Link to heading"></i>
<span class=sr-only>Link to heading</span></a></h2><p>Kubernetes extends simplicity to cluster management by presenting resources through APIs. Every object—Pods, Deployments, Services, ConfigMaps, and beyond—exists in the system as its own object but can be represented as a <strong>YAML/JSON resource</strong> that you query and modify via the <strong>Kubernetes API Server</strong>.</p><p>Kubernetes provides an abstraction for cluster management by presenting resources through APIs. Every object — Pods, Deployments, Services, ConfigMaps, and more — exists as an <strong>API object</strong> within the cluster&rsquo;s control plane. As a Kubernetes administrator, you interact with these objects using <strong>YAML or JSON resource specifications</strong>, which can be queried and modified via the <strong>Kubernetes API Server</strong>.</p><p>The <code>kubectl</code> command-line tool serves as the primary interface for interacting with the API Server, enabling you to manage resources declaratively. For example:</p><div class=highlight><pre tabindex=0 style=color:#e6edf3;background-color:#0d1117;-moz-tab-size:4;-o-tab-size:4;tab-size:4><code class=language-bash data-lang=bash><span style=display:flex><span><span style=color:#8b949e;font-style:italic># Get a YAML representation of a pod</span>
</span></span><span style=display:flex><span>kubectl get pod &lt;pod-name&gt; -o yaml
</span></span></code></pre></div><p>This API-centric design is what makes so Kubernetes powerful and extensible. Every API object defined in Kubernetes is eventually translated into operations that the underlying Linux OS can understand — whether it&rsquo;s creating network namespaces for Pods, writing iptables rules for Services, or mounting volumes for PersistentVolumeClaims. By breaking down its core principles, we can better understand how Kubernetes bridges its API abstractions to the Linux systems it orchestrates.</p><p><strong>Key Aspects</strong></p><p>Kubernetes relies on a few core principles to manage and orchestrate resources effectively. One of the most fundamental is its <strong>declarative configuration model</strong>, which allows you to define the desired state of your infrastructure in files.</p><ol><li><p><strong>Declarative Configuration</strong><br>You describe your desired state in a file:</p><div class=highlight><pre tabindex=0 style=color:#e6edf3;background-color:#0d1117;-moz-tab-size:4;-o-tab-size:4;tab-size:4><code class=language-yaml data-lang=yaml><span style=display:flex><span><span style=color:#7ee787>apiVersion</span>:<span style=color:#6e7681> </span><span style=color:#a5d6ff>apps/v1</span><span style=color:#6e7681>
</span></span></span><span style=display:flex><span><span style=color:#6e7681></span><span style=color:#7ee787>kind</span>:<span style=color:#6e7681> </span><span style=color:#a5d6ff>Deployment</span><span style=color:#6e7681>
</span></span></span><span style=display:flex><span><span style=color:#6e7681></span><span style=color:#7ee787>metadata</span>:<span style=color:#6e7681>
</span></span></span><span style=display:flex><span><span style=color:#6e7681>  </span><span style=color:#7ee787>name</span>:<span style=color:#6e7681> </span><span style=color:#a5d6ff>nginx-deployment</span><span style=color:#6e7681>
</span></span></span><span style=display:flex><span><span style=color:#6e7681></span><span style=color:#7ee787>spec</span>:<span style=color:#6e7681>
</span></span></span><span style=display:flex><span><span style=color:#6e7681>  </span><span style=color:#7ee787>replicas</span>:<span style=color:#6e7681> </span><span style=color:#a5d6ff>3</span><span style=color:#6e7681>
</span></span></span><span style=display:flex><span><span style=color:#6e7681>  </span><span style=color:#7ee787>selector</span>:<span style=color:#6e7681>
</span></span></span><span style=display:flex><span><span style=color:#6e7681>    </span><span style=color:#7ee787>matchLabels</span>:<span style=color:#6e7681>
</span></span></span><span style=display:flex><span><span style=color:#6e7681>      </span><span style=color:#7ee787>app</span>:<span style=color:#6e7681> </span><span style=color:#a5d6ff>nginx</span><span style=color:#6e7681>
</span></span></span><span style=display:flex><span><span style=color:#6e7681>  </span><span style=color:#7ee787>template</span>:<span style=color:#6e7681>
</span></span></span><span style=display:flex><span><span style=color:#6e7681>    </span><span style=color:#7ee787>metadata</span>:<span style=color:#6e7681>
</span></span></span><span style=display:flex><span><span style=color:#6e7681>      </span><span style=color:#7ee787>labels</span>:<span style=color:#6e7681>
</span></span></span><span style=display:flex><span><span style=color:#6e7681>        </span><span style=color:#7ee787>app</span>:<span style=color:#6e7681> </span><span style=color:#a5d6ff>nginx</span><span style=color:#6e7681>
</span></span></span><span style=display:flex><span><span style=color:#6e7681>    </span><span style=color:#7ee787>spec</span>:<span style=color:#6e7681>
</span></span></span><span style=display:flex><span><span style=color:#6e7681>      </span><span style=color:#7ee787>containers</span>:<span style=color:#6e7681>
</span></span></span><span style=display:flex><span><span style=color:#6e7681>      </span>- <span style=color:#7ee787>name</span>:<span style=color:#6e7681> </span><span style=color:#a5d6ff>nginx</span><span style=color:#6e7681>
</span></span></span><span style=display:flex><span><span style=color:#6e7681>        </span><span style=color:#7ee787>image</span>:<span style=color:#6e7681> </span><span style=color:#a5d6ff>nginx:latest</span><span style=color:#6e7681>
</span></span></span><span style=display:flex><span><span style=color:#6e7681>
</span></span></span><span style=display:flex><span><span style=color:#6e7681></span><span style=color:#a5d6ff>A simple `kubectl apply -f deployment.yaml` makes Kubernetes reconcile the current state to match it.</span><span style=color:#6e7681>
</span></span></span></code></pre></div></li><li><p><strong>Central API Server</strong></p><ul><li>The <strong>control plane</strong> tracks resources in <code>etcd</code> and manages cluster state.</li><li>Tools like <code>kubectl</code> or custom controllers interact with the API to create, read, update, or delete objects.</li></ul></li><li><p><strong>CRDs and Operators</strong></p><ul><li><p><strong>CRDs (Custom Resource Definitions):</strong> These allow you to extend Kubernetes by defining new types of resources beyond the built-in ones (e.g., Pods, Deployments). A CRD acts as a blueprint for creating custom API objects that Kubernetes can manage just like native resources.</p></li><li><p><strong>Operators:</strong> Operators are specialized controllers that manage the lifecycle of custom resources defined by CRDs. They monitor the state of these resources and take actions to ensure the desired state is maintained. This brings automation and intelligence to Kubernetes, effectively turning operational tasks into code.</p><ul><li>Example: The <a href=https://github.com/cloudnative-pg/cloudnative-pg class=external-link target=_blank rel=noopener>CloudNativePG</a> Operator automates tasks like provisioning PostgreSQL instances, setting up replication, and performing backups or failover operations based on the <code>PostgresCluster</code> CRD.</li><li>Key Components:<ol><li><strong>Custom Resources</strong>: Created using the CRD.</li><li><strong>Reconciliation Logic</strong>: The Operator’s code continuously ensures the desired state of the resource is achieved, even if failures occur.</li></ol></li></ul></li></ul></li><li><p><strong>CRDs and Operators</strong></p><ul><li><p><strong>CRDs (Custom Resource Definitions):</strong> These allow you to extend Kubernetes by defining new types of resources beyond the built-in ones (e.g., Pods, Deployments). A CRD acts as a blueprint for creating custom API objects that Kubernetes can manage just like native resources.</p><ul><li>Example: The <code>Cluster</code> CRD used by the CloudNativePG Operator to manage PostgreSQL clusters.</li></ul></li><li><p><strong>Operators:</strong> Operators are specialized controllers that manage the lifecycle of custom resources defined by CRDs. They monitor the state of these resources and take actions to ensure the desired state is maintained. This brings automation and intelligence to Kubernetes, effectively turning operational tasks into code.</p><ul><li>Example: The CloudNativePG Operator automates tasks like provisioning PostgreSQL instances, initializing the database, and ensuring high availability or backups based on the <code>Cluster</code> CRD.</li><li>Key Components:<ol><li><strong>Custom Resources</strong>: Created using the CRD.</li><li><strong>Reconciliation Logic</strong>: The Operator’s code continuously ensures the desired state of the resource is achieved, even if failures occur.</li></ol></li></ul></li></ul><p><strong>How It Works</strong>:</p><ol><li><p>Define the <code>Cluster</code> CRD:
The CloudNativePG Operator introduces a CRD that allows users to define their desired PostgreSQL cluster configuration. Here’s an example:</p><div class=highlight><pre tabindex=0 style=color:#e6edf3;background-color:#0d1117;-moz-tab-size:4;-o-tab-size:4;tab-size:4><code class=language-yaml data-lang=yaml><span style=display:flex><span><span style=color:#7ee787>apiVersion</span>:<span style=color:#6e7681> </span><span style=color:#a5d6ff>postgresql.cnpg.io/v1</span><span style=color:#6e7681>
</span></span></span><span style=display:flex><span><span style=color:#6e7681></span><span style=color:#7ee787>kind</span>:<span style=color:#6e7681> </span><span style=color:#a5d6ff>Cluster</span><span style=color:#6e7681>
</span></span></span><span style=display:flex><span><span style=color:#6e7681></span><span style=color:#7ee787>metadata</span>:<span style=color:#6e7681>
</span></span></span><span style=display:flex><span><span style=color:#6e7681>  </span><span style=color:#7ee787>name</span>:<span style=color:#6e7681> </span><span style=color:#a5d6ff>cluster-example-initdb</span><span style=color:#6e7681>
</span></span></span><span style=display:flex><span><span style=color:#6e7681></span><span style=color:#7ee787>spec</span>:<span style=color:#6e7681>
</span></span></span><span style=display:flex><span><span style=color:#6e7681>  </span><span style=color:#7ee787>instances</span>:<span style=color:#6e7681> </span><span style=color:#a5d6ff>3</span><span style=color:#6e7681>
</span></span></span><span style=display:flex><span><span style=color:#6e7681>
</span></span></span><span style=display:flex><span><span style=color:#6e7681>  </span><span style=color:#7ee787>bootstrap</span>:<span style=color:#6e7681>
</span></span></span><span style=display:flex><span><span style=color:#6e7681>    </span><span style=color:#7ee787>initdb</span>:<span style=color:#6e7681>
</span></span></span><span style=display:flex><span><span style=color:#6e7681>      </span><span style=color:#7ee787>database</span>:<span style=color:#6e7681> </span><span style=color:#a5d6ff>app</span><span style=color:#6e7681>
</span></span></span><span style=display:flex><span><span style=color:#6e7681>      </span><span style=color:#7ee787>owner</span>:<span style=color:#6e7681> </span><span style=color:#a5d6ff>app</span><span style=color:#6e7681>
</span></span></span><span style=display:flex><span><span style=color:#6e7681>      </span><span style=color:#7ee787>secret</span>:<span style=color:#6e7681>
</span></span></span><span style=display:flex><span><span style=color:#6e7681>        </span><span style=color:#7ee787>name</span>:<span style=color:#6e7681> </span><span style=color:#a5d6ff>app-secret</span><span style=color:#6e7681>
</span></span></span><span style=display:flex><span><span style=color:#6e7681>
</span></span></span><span style=display:flex><span><span style=color:#6e7681>  </span><span style=color:#7ee787>storage</span>:<span style=color:#6e7681>
</span></span></span><span style=display:flex><span><span style=color:#6e7681>    </span><span style=color:#7ee787>size</span>:<span style=color:#6e7681> </span><span style=color:#a5d6ff>1Gi</span><span style=color:#6e7681>
</span></span></span></code></pre></div></li><li><p>Deploy the CloudNativePG Operator:
The Operator monitors the <code>Cluster</code> resource and translates it into Kubernetes-native components such as Pods, StatefulSets, PersistentVolumeClaims, and Services.</p></li><li><p>The Operator’s Lifecycle Management:
When the <code>Cluster</code> resource is applied using <code>kubectl apply -f cluster-example-initdb.yaml</code>, the Operator:</p></li></ol><ul><li>Creates the specified number of PostgreSQL instances (three in this case).</li><li>Initializes the database (<code>app</code>) with the specified owner (<code>app</code>) and secrets for authentication.</li><li>Allocates persistent storage of <code>1Gi</code> per instance for database files.</li></ul><ol start=4><li>Automated Reconciliation:
The Operator continuously ensures the PostgreSQL cluster matches the specified configuration. For example:</li></ol><ul><li>If a Pod crashes, the Operator recreates it.</li><li>If you update the configuration, the Operator applies the changes to the cluster.</li></ul></li></ol><h2 id=4-where-kubernetes-defers-to-linux>4. Where Kubernetes Defers to Linux
<a class=heading-link href=#4-where-kubernetes-defers-to-linux><i class="fa-solid fa-link" aria-hidden=true title="Link to heading"></i>
<span class=sr-only>Link to heading</span></a></h2><p>Even though Kubernetes is heavily API-driven, certain tasks rely on more directly on the underlying operating system. Here are the main areas:</p><h3 id=41-cni-container-network-interface>4.1 CNI (Container Network Interface)
<a class=heading-link href=#41-cni-container-network-interface><i class="fa-solid fa-link" aria-hidden=true title="Link to heading"></i>
<span class=sr-only>Link to heading</span></a></h3><ul><li><strong>What it is</strong>: A specification that network plugins use to configure pod networking — assigning IP addresses, setting up routes, etc.</li><li><strong>Why it’s not purely an API</strong>:<ul><li>The <strong>CNI plugin</strong> runs on each node host, modifying Linux networking constructs (iptables, routes, <a href=https://man7.org/linux/man-pages/man4/veth.4.html class=external-link target=_blank rel=noopener>veth pairs</a>).</li><li>Kubernetes itself just invokes the plugin; the heavy lifting happens at the Linux level.</li></ul></li></ul><p><strong>Troubleshooting Example</strong>:</p><div class=highlight><pre tabindex=0 style=color:#e6edf3;background-color:#0d1117;-moz-tab-size:4;-o-tab-size:4;tab-size:4><code class=language-bash data-lang=bash><span style=display:flex><span><span style=color:#8b949e;font-style:italic># Check iptables rules on a node</span>
</span></span><span style=display:flex><span>iptables -L -t nat
</span></span><span style=display:flex><span>
</span></span><span style=display:flex><span><span style=color:#8b949e;font-style:italic># List network namespaces</span>
</span></span><span style=display:flex><span>ip netns list
</span></span></code></pre></div><p>If you see unexpected routing or NAT rules, the issue often lies in the CNI plugin configuration, not in the Kubernetes API definitions.</p><hr><h3 id=42-csi-container-storage-interface>4.2 CSI (Container Storage Interface)
<a class=heading-link href=#42-csi-container-storage-interface><i class="fa-solid fa-link" aria-hidden=true title="Link to heading"></i>
<span class=sr-only>Link to heading</span></a></h3><ul><li><strong>What it is</strong>: A standardized interface for storage plugins to provision and attach volumes dynamically.</li><li><strong>Why it’s not purely an API</strong>:<ul><li>While you create <strong>PersistentVolumeClaims (PVCs)</strong> via the Kubernetes API, the actual block devices and mount points live on the node’s filesystem.</li><li>The <strong>CSI plugin</strong> is responsible for orchestrating filesystem operations (e.g., <code>mount</code>, <code>umount</code>) on the host.</li></ul></li></ul><p><strong>Troubleshooting</strong>:</p><div class=highlight><pre tabindex=0 style=color:#e6edf3;background-color:#0d1117;-moz-tab-size:4;-o-tab-size:4;tab-size:4><code class=language-bash data-lang=bash><span style=display:flex><span><span style=color:#8b949e;font-style:italic># Inspect where volumes are mounted</span>
</span></span><span style=display:flex><span>mount | grep pvc
</span></span><span style=display:flex><span>
</span></span><span style=display:flex><span><span style=color:#8b949e;font-style:italic># Check PVC binding status</span>
</span></span><span style=display:flex><span>kubectl describe pvc my-volume-claim
</span></span></code></pre></div><p>If the PVC is stuck in <code>Pending</code>, the plugin or underlying storage backend might be misconfigured.</p><hr><h3 id=43-cri-container-runtime-interface>4.3 CRI (Container Runtime Interface)
<a class=heading-link href=#43-cri-container-runtime-interface><i class="fa-solid fa-link" aria-hidden=true title="Link to heading"></i>
<span class=sr-only>Link to heading</span></a></h3><ul><li><strong>What it is</strong>: The interface between kubelet and container runtimes (e.g., containerd, CRI-O).</li><li><strong>Why it’s not purely an API</strong>:<ul><li>Container logs, filesystems, and runtime states live on the host.</li><li>Although kubelet interacts with the runtime using gRPC calls (a form of API), the underlying container management relies on Linux cgroups, namespaces, and file paths (e.g., <code>/var/lib/containerd</code>).</li></ul></li></ul><p><strong>Troubleshooting</strong>:</p><div class=highlight><pre tabindex=0 style=color:#e6edf3;background-color:#0d1117;-moz-tab-size:4;-o-tab-size:4;tab-size:4><code class=language-bash data-lang=bash><span style=display:flex><span><span style=color:#8b949e;font-style:italic># Logs from containerd runtime</span>
</span></span><span style=display:flex><span>journalctl -u containerd
</span></span><span style=display:flex><span>
</span></span><span style=display:flex><span><span style=color:#8b949e;font-style:italic># Check container logs at node level (locations may vary)</span>
</span></span><span style=display:flex><span>ls /var/log/containers/
</span></span></code></pre></div><hr><h3 id=44-other-nuances>4.4 Other Nuances
<a class=heading-link href=#44-other-nuances><i class="fa-solid fa-link" aria-hidden=true title="Link to heading"></i>
<span class=sr-only>Link to heading</span></a></h3><ul><li><strong>kube-proxy</strong>: Implements Kubernetes <code>Service</code> networking by writing iptables or IPVS rules directly on the node.</li><li><strong>CoreDNS</strong>: Configured via Kubernetes objects, but ultimately relies on Linux’s DNS resolution stack.</li></ul><hr><h2 id=5-putting-it-together-debugging-with-linux--kubernetes-tools>5. Putting It Together: Debugging with Linux & Kubernetes Tools
<a class=heading-link href=#5-putting-it-together-debugging-with-linux--kubernetes-tools><i class="fa-solid fa-link" aria-hidden=true title="Link to heading"></i>
<span class=sr-only>Link to heading</span></a></h2><p>When a service misbehaves in Kubernetes, you’ll combine <strong>API-based</strong> and <strong>file-based</strong> diagnostics:</p><ol><li><p><strong>Check the Kubernetes API</strong>:</p><div class=highlight><pre tabindex=0 style=color:#e6edf3;background-color:#0d1117;-moz-tab-size:4;-o-tab-size:4;tab-size:4><code class=language-bash data-lang=bash><span style=display:flex><span>kubectl get pods
</span></span><span style=display:flex><span>kubectl describe pod &lt;pod&gt;
</span></span><span style=display:flex><span>kubectl logs &lt;pod&gt;
</span></span></code></pre></div><p>This reveals what the control plane knows.</p></li><li><p><strong>Inspect the Host (Linux)</strong>:</p><div class=highlight><pre tabindex=0 style=color:#e6edf3;background-color:#0d1117;-moz-tab-size:4;-o-tab-size:4;tab-size:4><code class=language-bash data-lang=bash><span style=display:flex><span><span style=color:#8b949e;font-style:italic># Network debugging</span>
</span></span><span style=display:flex><span>iptables -L -t nat
</span></span><span style=display:flex><span>ip route
</span></span><span style=display:flex><span>
</span></span><span style=display:flex><span><span style=color:#8b949e;font-style:italic># Storage debugging</span>
</span></span><span style=display:flex><span>mount | grep pvc
</span></span><span style=display:flex><span>
</span></span><span style=display:flex><span><span style=color:#8b949e;font-style:italic># GPU debugging (on a node)</span>
</span></span><span style=display:flex><span>dmesg | grep nvidia
</span></span></code></pre></div></li></ol><p>Understanding which layer you’re debugging—API or Linux—will guide you to the right tools.</p><hr><h2 id=6-best-practices-for-linux-engineers-in-kubernetes>6. Best Practices for Linux Engineers in Kubernetes
<a class=heading-link href=#6-best-practices-for-linux-engineers-in-kubernetes><i class="fa-solid fa-link" aria-hidden=true title="Link to heading"></i>
<span class=sr-only>Link to heading</span></a></h2><ol><li><p><strong>Know the Boundaries</strong></p><ul><li>Use Kubernetes commands (<code>kubectl</code>) for API-level insights.</li><li>Use Linux commands (<code>ip</code>, <code>mount</code>, <code>ls /dev</code>) for host-level checks, including GPU nodes.</li></ul></li><li><p><strong>Avoid Over-Reliance on <code>kubectl</code></strong></p><ul><li>Some failures manifest at the OS level; a quick <code>ip a</code> or <code>mount</code> can unearth root causes faster than scanning YAML files.</li></ul></li><li><p><strong>Use Official Docs</strong></p><ul><li><strong>Kubernetes</strong>: <a href=https://kubernetes.io/docs/home/ class=external-link target=_blank rel=noopener>Kubernetes Documentation</a></li><li><strong>Linux</strong>: <a href=https://www.kernel.org/doc/html/latest/ class=external-link target=_blank rel=noopener>Kernel Docs</a></li><li><strong>NVIDIA Device Plugin</strong>: <a href=https://docs.nvidia.com/datacenter/cloud-native/ class=external-link target=_blank rel=noopener>NVIDIA Documentation</a></li></ul></li></ol><hr><h2 id=7-conclusion>7. Conclusion
<a class=heading-link href=#7-conclusion><i class="fa-solid fa-link" aria-hidden=true title="Link to heading"></i>
<span class=sr-only>Link to heading</span></a></h2><p>Kubernetes’ <em>“everything is an API”</em> parallels Linux’s <em>“everything is a file”</em>, just at a higher abstraction. For the seasoned Linux engineer, this means:</p><ul><li>You already have the foundational skillset to diagnose Kubernetes issues, from networking & performance to GPUs.</li><li>Kubernetes simply introduces another layer of APIs to handle container orchestration at scale.</li><li>By blending <strong>API-level</strong> knowledge with your <strong>Linux-level</strong> knowledge, you can tackle complex issues with confidence.</li></ul></div><footer></footer></article></section></div><footer class=footer><section class=container>©
2025
Tom
·
Powered by <a href=https://gohugo.io/ target=_blank rel=noopener>Hugo</a> & <a href=https://github.com/luizdepra/hugo-coder/ target=_blank rel=noopener>Coder</a>.</section></footer></main><script src=/js/coder.min.6ae284be93d2d19dad1f02b0039508d9aab3180a12a06dcc71b0b0ef7825a317.js integrity="sha256-auKEvpPS0Z2tHwKwA5UI2aqzGAoSoG3McbCw73gloxc="></script></body></html>